/*
* ============================================================================
*  Name        : ./accesssec/eapol/eapol_framework/wapi_common/include/wapi_core.h
*  Part of     : WAPI / WAPI       *** Info from the SWAD
*  Description : WAPI authentication
*  Version     : %version: 68.1.2 % << Don't touch! Updated by Synergy at check-out.
*
*  Copyright © 2001-2009 Nokia.  All rights reserved.
*  This material, including documentation and any related computer
*  programs, is protected by copyright controlled by Nokia.  All
*  rights are reserved.  Copying, including reproducing, storing,
*  adapting or translating, any or all of this material requires the
*  prior written consent of Nokia.  This material also contains
*  confidential information which may not be disclosed to others
*  without the prior written consent of Nokia.
* ============================================================================
* Template version: 4.2
*/



/**
 *  @mainpage WAPI Core documentation.
 *  
 *  @section intro Introduction
 *  This is a WAPI Core documentation generated by doxygen.
 *  First read <a href="../../doc/WAPI/WAPI_design.doc">WAPI_design.doc</a>
 *  file from <a href="../../doc/WAPI/">WAPI documentation</a> directory.
 *  
 *  @section install Installation
 *  Installation instructions are in file <a href="../../../../../wlaneapol/internal/wlaneapol_linux/readme.txt">readme.txt</a>.
 *  
 *  @section classes Most crucial classes
 *  The most crucial classes are wapi_core_c, abs_wapi_core_c, ec_certificate_store_c, ec_algorithms_c.
 *
 *  Implementation of wapi_core_c class is in a file <a href="../src/wapi_core.cpp">
 *  wapi_core.cpp</a>. 
 *  
 */


#if !defined(_WAPI_CORE_H_)
#define _WAPI_CORE_H_

#include "eap_am_export.h"
#include "eap_core_map.h"
#include "eap_am_network_id.h"
#include "abs_eap_stack_interface.h"
#include "eap_configuration_field.h"
#include "abs_eap_core_map.h"
#include "wapi_types.h"
#include "wai_usksa.h"
#include "wai_message.h"
#include "eapol_rsna_key_header.h"
#include "abs_ec_certificate_store.h"
#include "ec_certificate_store.h"
#include "wai_message_payloads.h"
#include "wapi_core_retransmission.h"
#include "abs_wapi_am_core.h"

class abs_wapi_core_c;
class abs_eap_am_tools_c;
class eap_core_retransmission_c;
class eap_variable_data_c;
class wai_protocol_packet_header_c;
class wai_usksa_c;
class wai_message_payloads_c;
class wai_variable_data_c;
class wapi_am_base_core_c;

//--------------------------------------------------------------------------------------------------

/**
 *  @defgroup WAPI_Core_config_options Configuration options of WAPI Core.
 *  The following configuration options are read through abs_eap_base_type_c::read_configure() function.
 *  @{
 */

/**
 *  This is u32_t configuration option.
 *  This is the maximum count WAPI CORE Authenticator resents message again.
 *  This is used in simulator testing.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_retransmission_counter,
	"WAPI_CORE_retransmission_counter",
	eap_configure_type_u32_t,
	false);

/**
 *  This is u32_t configuration option.
 *  This is the time after WAPI CORE Authenticator resents message again.
 *  This is used in simulator testing.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_retransmission_time,
	"WAPI_CORE_retransmission_time",
	eap_configure_type_u32_t,
	false);

/**
 *  This is u32_t configuration option.
 *  This is the maximum time WAPI authentication could succeed.
 *  Authentication is terminated after this time elapses.
 *  Time is in milli secons.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_session_timeout,
	"WAPI_CORE_session_timeout",
	eap_configure_type_u32_t,
	false);

/**
 *  This is optional and only valid for server.
 *  This allows different values for client and server.
 *  This is u32_t configuration option.
 *  This is the maximum time WAPI authentication could succeed.
 *  Authentication is terminated after this time elapses.
 *  Time is in milli secons.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_server_session_timeout,
	"WAPI_CORE_server_session_timeout",
	eap_configure_type_u32_t,
	false);

/**
 *  This is u32_t configuration option.
 *  This is the time after failure is handled.
 *  Zero means failure is handled immediately.
 *  Time is in milli secons.
 *  The default value is WAPI_CORE_FAILURE_RECEIVED_TIMEOUT.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_failure_received_timeout,
	"WAPI_CORE_failure_received_timeout",
	eap_configure_type_u32_t,
	false);

/**
 *  This is Hex-data configuration option.
 *  This is the PSK used in WAPI testing.
 *  The default value is empty.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_PSK,
	"WAPI_CORE_PSK",
	eap_configure_type_hex_data,
	false);

/**
 *  This is u32_t configuration option.
 *  This is the index of used database row in current connection.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_database_reference_index,
	"WAPI_database_reference_index",
	eap_configure_type_u32_t,
	false);

/**
 *  This boolean configuration option value true uses only initial authentication.
 *  Default value is false, uses also rekeying.
 */
EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_server_only_initial_authentication,
	"WAPI_CORE_server_only_initial_authentication",
	eap_configure_type_boolean,
	false);

EAP_CONFIGURATION_FIELD(
	cf_str_WAPI_CORE_server_test_other_asu_id,
	"WAPI_CORE_server_test_other_asu_id",
	eap_configure_type_hex_data,
	false);

/** @} */ // End of group WAPI_Core_config_options.


//--------------------------------------------------------------------------------------------------


/**
 * This is the timer ID used with abs_eap_am_tools_c::set_timer() and abs_eap_am_tools_c::cancel_timer().
 */
enum wapi_core_timer_id
{
	WAPI_CORE_TIMER_RETRANSMISSION_ID,            ///< This is time after a WPI-message is resent again. This is for testing purposes. See USE_WAPI_CORE_RETRANSMISSION compilation flag.
	WAPI_CORE_SESSION_TIMEOUT_ID, ///< See WAPI_CORE_TIMER_HANDLER_TIMEOUT.
	WAPI_CORE_FAILURE_RECEIVED_ID, ///< See WAPI_CORE_FAILURE_RECEIVED_TIMEOUT.
	WAPI_CORE_REMOVE_SESSION_TIMEOUT_ID,  ///< See WAPI_CORE_REMOVE_SESSION_TIMEOUT.
};

/**
 * This is time after a failed message is handled.
 */
const u32_t WAPI_CORE_FAILURE_RECEIVED_TIMEOUT = 2000ul;

/**
 * This is the size of the local send buffer. Please use atleast minimum ethernet packet length 60 bytes.
 */
const u32_t WAPI_CORE_PACKET_BUFFER_LENGTH = 512u;


/**
 * Re-transmission is used to test protocols.
 * This is the maximum count WAPI message is resent again.
 * This is used in simulator testing.
 * This is configurable parameter. See eap.conf WAPI_CORE_retransmission_counter.
 */
const u32_t WAPI_CORE_RETRANSMISSION_COUNTER = 5;

/**
 * Re-transmission is used to test protocols.
 * This is the time after WAPI message is resent again.
 * This is used in simulator testing.
 * This is configurable parameter. See eap.conf WAPI_CORE_retransmission_time.
 */
const u32_t WAPI_CORE_RETRANSMISSION_TIME = 1000u; /* milli seconds */

/**
 * This is the maximum time WAPI authentication could succeed.
 * Authentication is terminated after this time elapses.
 * This is configurable parameter. See eap.conf WAPI_CORE_session_timeout.
 * See WAPI_CORE_SESSION_TIMEOUT_ID.
 * Time is in milli seconds. 
 */
const u32_t WAPI_CORE_SESSION_TIMEOUT = 120000u; /* milli seconds */

/**
 * This is the delay time after WAPI-session is removed after authentication finished.
 * This is configurable parameter.
 * See WAPI_CORE_REMOVE_SESSION_TIMEOUT_ID.
 * Time is in milli seconds. 
 */
const u32_t WAPI_CORE_REMOVE_SESSION_TIMEOUT = 10000ul; /* milli seconds */


//--------------------------------------------------------------------------------------------------


/// A wapi_core_c class implements the basic functionality of WAPI-protocol.
class EAP_EXPORT wapi_core_c
: public abs_eap_core_map_c
, public abs_eap_base_timer_c
, public abs_eap_stack_interface_c
, public abs_ec_certificate_store_c
, public abs_wapi_am_core_c
{
private:
	//--------------------------------------------------

	/// This is back pointer to object which created this object.
	/// Packets are sent to the partner.
	abs_wapi_core_c *m_partner;

	ec_base_certificate_store_c * m_ec_certificate_store;

	wapi_am_base_core_c *m_am_wapi_core;

	/// This is pointer to the tools class.
	abs_eap_am_tools_c * const m_am_tools;

	/// This is offset in bytes of the WAPI-header.
	u32_t m_wapi_header_offset;

	/// This is maximum transfer unit in bytes.
	u32_t m_MTU;

	/// This is length of the trailer in bytes.
	u32_t m_trailer_length;

	/// This is network identity of the received packet.
	eap_am_network_id_c m_receive_network_id;

	/// Re-transmission is used to test protocols.
	/// This stores the information to resent a message. This is used for testing purposes.
	eap_array_c<wapi_core_retransmission_c> m_retransmission;

	/// Re-transmission is used to test protocols.
	/// This is the time after resent a message. This is used for testing purposes.
	u32_t m_retransmission_time;

	/// Re-transmission is used to test protocols.
	/// This is the maximum count of retransmission of one message. This is used for testing purposes.
	u32_t m_retransmission_counter;

	/// This is the maximum time authentication could succeed.
	/// Authentication is terminated after this time elapses.
	/// The WAPI could change the timeout by calling set_session_timeout() function.
	u32_t m_session_timeout;

	u32_t m_wapi_core_failure_received_timeout;

	u32_t m_remove_session_timeout;

	wapi_core_state_e m_wapi_state;

	wai_message_c m_received_wai_message_data;

	wai_message_payloads_c m_new_payloads;

	eap_variable_data_c m_preshared_key_PSK;

	eap_variable_data_c m_BK;

	eap_variable_data_c m_BKID;

	u8_t m_USKID;

	u8_t m_MSKID;

	wai_usksa_c * m_USKSA[WAPI_USKSA_COUNT];

	wai_usksa_c * m_MSKSA[WAPI_MSKSA_COUNT];

	eap_variable_data_c m_ae_certificate_challenge;
	eap_variable_data_c m_asue_certificate_challenge;

	eap_variable_data_c m_ae_unicast_challenge;
	eap_variable_data_c m_asue_unicast_challenge;

	eap_variable_data_c m_authentication_identifier;

	eap_variable_data_c m_asue_id;
	eap_variable_data_c m_asu_id;
	eap_variable_data_c m_ae_id;

	// This is for testing purposes.
	eap_variable_data_c m_test_other_asu_id;

	eap_variable_data_c m_own_certificate;
	eap_variable_data_c m_peer_certificate;
	eap_variable_data_c m_ae_certificate;

	eap_variable_data_c m_wapi_ie_asue;
	eap_variable_data_c m_wapi_ie_ae;

	eap_variable_data_c m_unicast_encryption_key_UEK;
	eap_variable_data_c m_unicast_integrity_check_key_UCK;
	eap_variable_data_c m_message_authentication_key_MAK;
	eap_variable_data_c m_key_encryption_key_KEK;

	eap_variable_data_c m_next_unicast_challenge;

	eap_variable_data_c m_multicast_key;
	eap_variable_data_c m_packet_data_number;
	eap_variable_data_c m_key_announcement;

	eap_variable_data_c m_own_private_key_d;
	eap_variable_data_c m_own_public_key_x;
	eap_variable_data_c m_own_public_key_y;

	eap_variable_data_c m_peer_public_key_x;
	eap_variable_data_c m_peer_public_key_y;

	wai_variable_data_c m_result_of_certificate_verification;
	wai_variable_data_c m_server_signature_trusted_by_asue;
	wai_variable_data_c m_server_signature_trusted_by_ae;

	eap_variable_data_c m_reassemble_packet;

	eapol_key_authentication_type_e m_authentication_type;

	wapi_negotiation_state_e m_wapi_negotiation_state;

	eapol_RSNA_key_header_c::eapol_RSNA_cipher_e m_wapi_pairwise_cipher;
	eapol_RSNA_key_header_c::eapol_RSNA_cipher_e m_wapi_group_cipher;

	u16_t m_packet_sequence_number;
	u8_t m_fragment_sequence_number;

	/// This indicates whether this object is client (true) or server (false).
	/// In terms of WAPI-protocol whether this network entity is WAPI-ASUE (true) or WAPI-ASU (false).
	bool m_is_client;

	/// This indicates whether the authentication role of this object is client (true) or server (false).
	/// In terms of WAPI-protocol whether this network entitys authentication role is WAPI-ASUE (true) or WAPI-ASU (false).
	bool m_is_client_role;

	/// This indicates whether this object was generated successfully.
	bool m_is_valid;

	/// Client has initiated restart.
	bool m_client_restart_authentication_initiated;

	/// This flag indicates that this object is marked to removed asynchronously.
	/// The very same object could be taken use before the removing timer elapses.
	bool m_marked_removed;

	/// Function shutdown() is called already.
	bool m_shutdown_was_called;

	bool m_do_certificate_validation;

#if defined(USE_WAPI_CORE_SERVER)
	bool m_only_initial_authentication;
#endif //#if defined(USE_WAPI_CORE_SERVER)

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	eap_status_e increase_u128_t_network_order(
		eap_variable_data_c * const u128_t_integer) const;

	void set_wapi_state(wapi_core_state_e wapi_state);

	/**
	 * Re-transmission is used to test protocols.
	 * This function resends the packet.
	 */
	eap_status_e resend_packet(
		const eap_am_network_id_c * const send_network_id,
		const wai_message_c * const wai_message_data,
		const u32_t retransmission_counter,
		const u16_t packet_sequence_number
		);

	/** 
	 * Re-transmission is used to test protocols.
	 * This function cancels retransmissions.
	 */
	eap_status_e cancel_retransmission();

	/**
	 * Re-transmission is used to test protocols.
	 * This function inits retransmission of sent packet.
	 */
	eap_status_e init_retransmission(
		const eap_am_network_id_c * const send_network_id,
		const wai_message_c * const received_wai_message_data,
		const wai_message_c * const new_wai_message_data,
		const u16_t packet_sequence_number,
		const wai_protocol_subtype_e wapi_subtype
		);

	eap_status_e check_retransmission(const wai_protocol_packet_header_c * const wai);


	/**
	 * This function cancels previous session timeout and initializes new timeout for the session.
	 */
	eap_status_e initialize_session_timeout(
		const u32_t session_timeout_ms);

	/**
	 * This function cancels timeout for a session.
	 */
	eap_status_e cancel_session_timeout();

	/**
	 * This function initializes timeout for received failure.
	 */
	eap_status_e set_wapi_failure_timeout();

	/**
	 * This function cancels timeout for received failure.
	 */
	eap_status_e cancel_wapi_failure_timeout();

	eap_status_e asynchronous_init_remove_wapi_session();

	eap_status_e initialize_asynchronous_init_remove_wapi_session(
		const u32_t remove_session_timeout);

	eap_status_e cancel_asynchronous_init_remove_wapi_session();

	eap_status_e init_end_of_session(
		const abs_eap_state_notification_c * const state);


	eap_status_e create_BKID(
		eap_variable_data_c * const BKID,
		const eap_am_network_id_c * const receive_network_id);

	eap_status_e packet_data_session_key(
		eap_variable_data_c * const key, ///< Here is the key.
		const eapol_key_type_e key_type, ///< This the type of the key.
		const u32_t key_index, ///< This is the index of the key.
		const bool key_tx_bit, ///< This is the TX bit of the key.
		const u8_t * const key_RSC, ///< This is the RSC counter
		const u32_t key_RSC_size ///< This is the size of RSC counter
		);

	eap_status_e create_unicast_key(
		const eap_variable_data_c * const BK,
		const eap_am_network_id_c * const receive_network_id,
		const eap_variable_data_c * const ae_challenge,
		const eap_variable_data_c * const asue_challenge,
		eap_variable_data_c * const unicast_encryption_key_UEK,
		eap_variable_data_c * const unicast_integrity_check_key_UCK,
		eap_variable_data_c * const message_authentication_key_MAK,
		eap_variable_data_c * const key_encryption_key_KEK,
		eap_variable_data_c * const challenge_seed);

	eap_status_e create_MAC(
		const wai_message_payloads_c * const payloads,
		eap_variable_data_c * const MAC);

	eap_status_e create_HASH(
		const wai_message_payloads_c * const payloads,
		const bool hash_all_payloads,
		eap_variable_data_c * const HASH);

	eap_status_e packet_send(
		wai_message_c * const m_new_wai_message_data,
		const wai_protocol_subtype_e wapi_subtype);

	eap_status_e packet_fragment(
		wai_message_c * const new_wai_message_data,
		const u16_t packet_sequence_number);

	eap_status_e packet_reassemble(const wai_protocol_packet_header_c * const wai);


#if defined(USE_WAPI_CORE_SERVER)

	eap_status_e start_certificate_negotiation();

	eap_status_e start_unicast_key_negotiation();

	eap_status_e start_multicast_key_announcement();

#endif //#if defined(USE_WAPI_CORE_SERVER)


	eap_status_e handle_authentication_activation(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);

#if defined(USE_WAPI_CORE_SERVER)
	eap_status_e handle_access_authentication_request(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);
#endif //#if defined(USE_WAPI_CORE_SERVER)

	eap_status_e handle_access_authentication_response(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);

	eap_status_e handle_unicast_key_negotiation_request(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);

#if defined(USE_WAPI_CORE_SERVER)
	eap_status_e handle_unicast_key_negotiation_response(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);
#endif //#if defined(USE_WAPI_CORE_SERVER)

	eap_status_e handle_unicast_key_negotiation_confirmation(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);


	eap_status_e handle_multicast_key_announcement(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);

#if defined(USE_WAPI_CORE_SERVER)
	eap_status_e handle_multicast_key_announcement_response(
		const eap_am_network_id_c * const receive_network_id,
		const wai_protocol_packet_header_c * const wai);
#endif //#if defined(USE_WAPI_CORE_SERVER)

#if defined(USE_WAPI_CORE_SERVER)
	eap_status_e encrypt_multicast_key_data(
		const eap_variable_data_c * const multicast_key,
		const eap_variable_data_c * const key_announcement,
		wai_variable_data_c * const key_data);
#endif //#if defined(USE_WAPI_CORE_SERVER)

	eap_status_e decrypt_multicast_key_data(
		const wai_variable_data_c * const key_data,
		const eap_variable_data_c * const key_announcement,
		eap_variable_data_c * const multicast_key);

	eap_status_e create_multicast_key(
		const eap_variable_data_c * const notification_master_key,
		eap_variable_data_c * const multicast_key);

	eap_status_e create_signature_attributes(
		wai_variable_data_c * const data_signature,
		const eap_variable_data_c * const asue_id,
		const eap_variable_data_c * const signature);

	eap_status_e parse_signature_attributes(
		const wai_variable_data_c * const data_signature,
		eap_variable_data_c * const asue_id,
		eap_variable_data_c * const signature);

	eap_status_e create_result_of_certificate_verification(
		wai_variable_data_c * const result_of_certificate_verification,
		const eap_variable_data_c * const ae_challenge,
		const eap_variable_data_c * const asue_challenge,
		const wapi_certificate_result_e asue_certificate_result,
		const eap_variable_data_c * const asue_certificate,
		const wapi_certificate_result_e ae_certificate_result,
		const eap_variable_data_c * const ae_certificate);

	eap_status_e parse_result_of_certificate_verification(
		const wai_variable_data_c * const result_of_certificate_verification,
		eap_variable_data_c * const ae_challenge,
		eap_variable_data_c * const asue_challenge,
		wapi_certificate_result_e * const asue_certificate_result,
		eap_variable_data_c * const asue_certificate,
		wapi_certificate_result_e * const ae_certificate_result,
		eap_variable_data_c * const ae_certificate);

	bool compare_issuer_name(const eap_variable_data_c * const asue_id, const eap_variable_data_c * const ae_id);

	//--------------------------------------------------
protected:
	//--------------------------------------------------

	//--------------------------------------------------
public:
	//--------------------------------------------------

	/**
	 * The destructor of the eap_core class does nothing special.
	 */
	EAP_FUNC_IMPORT virtual ~wapi_core_c();

	/**
	 * The constructor initializes member attributes using parameters passed to it.
	 * @param tools is pointer to the tools class. @see abs_eap_am_tools_c.
	 * @param partner is back pointer to object which created this object.
	 * @param is_client_when_true indicates whether the network entity should act
	 * as a client (true) or server (false), in terms of WAPI-protocol
	 * whether this network entity is WAPI-ASUE (true) or WAPI-ASU (false).
	 */
	EAP_FUNC_IMPORT wapi_core_c(
		abs_eap_am_tools_c * const tools,
		abs_wapi_core_c * const partner,
		const bool is_client_when_true,
		const eap_am_network_id_c * const receive_network_id);

	EAP_FUNC_IMPORT eap_status_e initialize(
		const eap_am_network_id_c * const receive_network_id,
		const eapol_key_authentication_type_e authentication_type);

	EAP_FUNC_IMPORT eap_status_e initialize(
		const eap_am_network_id_c * const receive_network_id,
		const eapol_key_authentication_type_e authentication_type,
		const eap_variable_data_c * const wapi_ie_ae,
		const eap_variable_data_c * const wapi_ie_asue,
		const eapol_RSNA_key_header_c::eapol_RSNA_cipher_e eapol_pairwise_cipher,
		const eapol_RSNA_key_header_c::eapol_RSNA_cipher_e eapol_group_cipher);

	// This is documented in abs_eap_stack_interface_c::packet_process().
	EAP_FUNC_IMPORT eap_status_e packet_process(
		const eap_am_network_id_c * const receive_network_id,
		eap_general_header_base_c * const packet_data,
		const u32_t packet_length); 

	// This is documented in abs_eap_base_type_c::packet_send().
	EAP_FUNC_IMPORT eap_status_e packet_send(
		const eap_am_network_id_c * const send_network_id,
		eap_buf_chain_wr_c * const sent_packet,
		const u32_t header_offset,
		const u32_t data_length,
		const u32_t buffer_length); 

	/**
	 * The get_partner() function returns pointer to partner class.
	 */
	EAP_FUNC_IMPORT abs_wapi_core_c * get_partner();

	/**
	 * The set_partner() function sets pointer to partner class.
	 */
	EAP_FUNC_IMPORT void set_partner(abs_wapi_core_c * const partner);

	// This is documented in abs_eap_base_type_c::get_header_offset().
	EAP_FUNC_IMPORT u32_t get_header_offset(
		u32_t * const MTU,
		u32_t * const trailer_length);

	// This is documented in abs_eap_base_type_c::restart_authentication().
	EAP_FUNC_IMPORT eap_status_e restart_authentication(
		const eap_am_network_id_c * const send_network_id,
		const bool is_client_when_true);

	// This is documented in abs_eap_stack_interface_c::configure().
	EAP_FUNC_IMPORT eap_status_e configure();

	// This is documented in abs_eap_stack_interface_c::shutdown().
	EAP_FUNC_IMPORT eap_status_e shutdown();

	// This is documented in abs_eap_base_type_c::read_configure().
	EAP_FUNC_IMPORT virtual eap_status_e read_configure(
		const eap_configuration_field_c * const field,
		eap_variable_data_c * const data);

	// This is documented in abs_eap_base_type_c::write_configure().
	EAP_FUNC_IMPORT virtual eap_status_e write_configure(
		const eap_configuration_field_c * const field,
		eap_variable_data_c * const data);

	// This is documented in abs_eap_stack_interface_c::set_is_valid().
	EAP_FUNC_IMPORT void set_is_valid();

	// This is documented in abs_eap_stack_interface_c::get_is_valid().
	EAP_FUNC_IMPORT bool get_is_valid();

	// This is documented in abs_eap_base_type_c::state_notification().
	EAP_FUNC_IMPORT void state_notification(
		const abs_eap_state_notification_c * const state);

	// See abs_eap_base_timer_c::timer_expired().
	EAP_FUNC_IMPORT eap_status_e timer_expired(
		const u32_t id, void *data);

	// See abs_eap_base_timer_c::timer_delete_data().
	EAP_FUNC_IMPORT eap_status_e timer_delete_data(
		const u32_t id, void *data);

	/**
	 * eap_core_map_c class increases reference count each time reference to stored object is get.
	 * Here is always just one state for one session so no references are used.
	 */
	EAP_FUNC_IMPORT void object_increase_reference_count();

	/**
	 * eap_core_map_c class increases reference count each time reference to stored object is get.
	 *  Here is always just one state for one session so no references are used.
	 */
	EAP_FUNC_IMPORT u32_t object_decrease_reference_count();

	/**
	 * Gets flag whether this session is marked removed.
	 * Session is removed later if it is not reused.
	 */
	EAP_FUNC_IMPORT bool get_marked_removed();

	/**
	 * Marks this session removed.
	 * Session is removed later if it is not reused.
	 */
	EAP_FUNC_IMPORT void set_marked_removed();

	/**
	 * Marks this session not removed.
	 * Session is not removed it is reused.
	 */
	EAP_FUNC_IMPORT void unset_marked_removed();

	/**
	 * This function must reset the state of object to same as 
	 * state was after the configure() function call.
	 * If object reset succeeds this function must return eap_status_ok.
	 * If object reset fails this function must return corresponding error status.
	 * @return This function returns the status of reset operation.
	 */
	EAP_FUNC_IMPORT eap_status_e reset();

	// This is documented in abs_eap_base_type_c::set_session_timeout().
	EAP_FUNC_IMPORT eap_status_e set_session_timeout(
		const u32_t session_timeout_ms);

	// This is documented in abs_eap_base_type_c::set_timer().
	EAP_FUNC_IMPORT eap_status_e set_timer(
		abs_eap_base_timer_c * const p_initializer, 
		const u32_t p_id, 
		void * const p_data,
		const u32_t p_time_ms);

	// This is documented in abs_eap_base_type_c::cancel_timer().
	EAP_FUNC_IMPORT eap_status_e cancel_timer(
		abs_eap_base_timer_c * const p_initializer, 
		const u32_t p_id);

	// This is documented in abs_eap_base_type_c::cancel_all_timers().
	EAP_FUNC_IMPORT eap_status_e cancel_all_timers();

	// This is documented in abs_eap_base_type_c::set_authentication_role().
	EAP_FUNC_IMPORT eap_status_e set_authentication_role(const bool when_true_set_client);

	EAP_FUNC_IMPORT eap_status_e cancel_authentication_session();

	EAP_FUNC_IMPORT eap_status_e check_bksa_cache(
		// ****
		// TODO: This needs to be updated for WAPI
		const eapol_key_authentication_type_e selected_eapol_key_authentication_type,
		const eapol_RSNA_key_header_c::eapol_RSNA_cipher_e pairwise_key_cipher_suite,
		const eapol_RSNA_key_header_c::eapol_RSNA_cipher_e group_key_cipher_suite);

	EAP_FUNC_IMPORT eap_status_e start_authentication();

	EAP_FUNC_IMPORT eap_status_e allow_authentication();

	EAP_FUNC_IMPORT eap_status_e init_bksa_caching_timeout();

	EAP_FUNC_IMPORT eap_status_e reset_cached_bksa();

	EAP_FUNC_IMPORT eap_status_e read_reassociation_parameters(
		const eap_am_network_id_c * const receive_network_id, ///< source includes remote address, destination includes local address.
		const eapol_key_authentication_type_e required_authentication_type,
		eap_variable_data_c * const PMKID,
		const eap_variable_data_c * const received_WPA_ie,
		const eap_variable_data_c * const sent_WPA_ie);


	// This is documented in abs_ec_certificate_store_c::complete_query_asu_id().
	EAP_FUNC_IMPORT eap_status_e complete_query_asu_id(
		const eap_variable_data_c * const asn1_der_subject_name,
		const eap_variable_data_c * const asn1_der_issuer_name,
		const eap_variable_data_c * const asn1_der_sequence_number,
		const eap_status_e id_status);

	// This is documented in abs_ec_certificate_store_c::complete_get_own_certificate().
	EAP_FUNC_IMPORT eap_status_e complete_get_own_certificate(
		const eap_variable_data_c * const own_certificate);

	// This is documented in abs_ec_certificate_store_c::complete_select_certificate().
	EAP_FUNC_IMPORT eap_status_e complete_select_certificate(
		const eap_variable_data_c * const issuer_ID,
		const eap_variable_data_c * const certificate_ID,
		const eap_variable_data_c * const certificate);

	// This is documented in abs_ec_certificate_store_c::complete_read_id_of_certificate().
	EAP_FUNC_IMPORT eap_status_e complete_read_id_of_certificate(
		const eap_variable_data_c * const ID);

	// This is documented in abs_ec_certificate_store_c::complete_create_signature_with_private_key().
	EAP_FUNC_IMPORT eap_status_e complete_create_signature_with_private_key(
		const eap_variable_data_c * const signature,
		const eap_status_e signature_status);

	// This is documented in abs_ec_certificate_store_c::complete_verify_signature_with_public_key().
	EAP_FUNC_IMPORT eap_status_e complete_verify_signature_with_public_key(
		const eap_status_e verification_status);

	// This is documented in abs_ec_certificate_store_c::complete_create_ecdh_temporary_keys().
	EAP_FUNC_IMPORT eap_status_e complete_create_ecdh_temporary_keys(
		const eap_variable_data_c * const private_key_d,
		const eap_variable_data_c * const public_key_x,
		const eap_variable_data_c * const public_key_y);

	// This is documented in abs_ec_certificate_store_c::complete_create_ecdh().
	EAP_FUNC_IMPORT eap_status_e complete_create_ecdh(
		const eap_variable_data_c * const K_AB_x4,
		const eap_variable_data_c * const K_AB_y4);


	//--------------------------------------------------
}; // class wapi_core_c


#endif //#if !defined(_WAPI_CORE_H_)

//--------------------------------------------------



// End.
